// Code generated by MockGen. DO NOT EDIT.
// Source: internal/usecase/interfaces.go

// Package mock_usecase is a generated GoMock package.
package usecase_test

import (
	context "context"
	reflect "reflect"

	entity "github.com/diogoalbuquerque/migration-customers/internal/entity"
	gomock "github.com/golang/mock/gomock"
)

// MockServiceLegacy is a mock of ServiceLegacy interface.
type MockServiceLegacy struct {
	ctrl     *gomock.Controller
	recorder *MockServiceLegacyMockRecorder
}

// MockServiceLegacyMockRecorder is the mock recorder for MockServiceLegacy.
type MockServiceLegacyMockRecorder struct {
	mock *MockServiceLegacy
}

// NewMockServiceLegacy creates a new mock instance.
func NewMockServiceLegacy(ctrl *gomock.Controller) *MockServiceLegacy {
	mock := &MockServiceLegacy{ctrl: ctrl}
	mock.recorder = &MockServiceLegacyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServiceLegacy) EXPECT() *MockServiceLegacyMockRecorder {
	return m.recorder
}

// LoadDatasource mocks base method.
func (m *MockServiceLegacy) LoadDatasource(ctx context.Context, limit int) ([]entity.LegacyPerson, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadDatasource", ctx, limit)
	ret0, _ := ret[0].([]entity.LegacyPerson)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadDatasource indicates an expected call of LoadDatasource.
func (mr *MockServiceLegacyMockRecorder) LoadDatasource(ctx, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadDatasource", reflect.TypeOf((*MockServiceLegacy)(nil).LoadDatasource), ctx, limit)
}

// Reconciliation mocks base method.
func (m *MockServiceLegacy) Reconciliation(ctx context.Context, legacyPeople []entity.LegacyPerson) ([]entity.LegacyPerson, []error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reconciliation", ctx, legacyPeople)
	ret0, _ := ret[0].([]entity.LegacyPerson)
	ret1, _ := ret[1].([]error)
	return ret0, ret1
}

// Reconciliation indicates an expected call of Reconciliation.
func (mr *MockServiceLegacyMockRecorder) Reconciliation(ctx, legacyPeople interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reconciliation", reflect.TypeOf((*MockServiceLegacy)(nil).Reconciliation), ctx, legacyPeople)
}

// MockServicePerson is a mock of ServicePerson interface.
type MockServicePerson struct {
	ctrl     *gomock.Controller
	recorder *MockServicePersonMockRecorder
}

// MockServicePersonMockRecorder is the mock recorder for MockServicePerson.
type MockServicePersonMockRecorder struct {
	mock *MockServicePerson
}

// NewMockServicePerson creates a new mock instance.
func NewMockServicePerson(ctrl *gomock.Controller) *MockServicePerson {
	mock := &MockServicePerson{ctrl: ctrl}
	mock.recorder = &MockServicePersonMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServicePerson) EXPECT() *MockServicePersonMockRecorder {
	return m.recorder
}

// Migrate mocks base method.
func (m *MockServicePerson) Migrate(ctx context.Context, legacyPeople []entity.LegacyPerson) ([]entity.LegacyPerson, []error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Migrate", ctx, legacyPeople)
	ret0, _ := ret[0].([]entity.LegacyPerson)
	ret1, _ := ret[1].([]error)
	return ret0, ret1
}

// Migrate indicates an expected call of Migrate.
func (mr *MockServicePersonMockRecorder) Migrate(ctx, legacyPeople interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Migrate", reflect.TypeOf((*MockServicePerson)(nil).Migrate), ctx, legacyPeople)
}
